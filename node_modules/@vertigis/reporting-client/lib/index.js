"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.run = exports.parseItemUrl = void 0;
/**
 * Parses a portal item URL string and returns the portal URL and item ID components.
 * @param url The URL of the portal item.
 * @returns An object containing the portal URL and the item ID.
 */
function parseItemUrl(url) {
    const portalItemRegex = /^(https?:\/\/.*?)\/home\/item.html.*?id=([a-f0-9]+)/i;
    const urlParts = portalItemRegex.exec(url);
    if (urlParts && urlParts.length > 2) {
        return {
            itemId: urlParts[2],
            portalUrl: urlParts[1],
        };
    }
    throw new Error("The item URL is invalid.");
}
exports.parseItemUrl = parseItemUrl;
/**
 * Runs a Geocortex report or print.
 * @param itemId The portal item ID of the report item.
 * @param options The options that define the report to run and how to run it.
 * @returns A URL to the report output file.
 */
async function run(itemId, options = {}) {
    var _a;
    if (!itemId) {
        throw new Error("itemId is required.");
    }
    // Ensure the portal URL doesn't end with a trailing slash
    const portalUrl = ((_a = options.portalUrl) === null || _a === void 0 ? void 0 : _a.replace(/\/$/, "")) || "https://www.arcgis.com";
    // Fetch the portal item
    const portalItemInfo = await getPortalItemInfo(itemId, portalUrl, options.token);
    // Ensure it is a valid item
    if (!isValidItemType(portalItemInfo)) {
        throw new Error(`The item '${itemId}' is not a valid template type.`);
    }
    if (!portalItemInfo.url) {
        throw new Error(`The item '${itemId}' does not contain a service URL.`);
    }
    // Infer the URL to the reporting service from the item
    const apiServiceUrl = `${portalItemInfo.url}service`;
    // Authentication
    const bearerToken = await getBearerToken(apiServiceUrl, portalUrl, options.token);
    // Start the reporting job
    const ticket = await startJob(portalUrl, itemId, apiServiceUrl, bearerToken, options.parameters, options.culture, options.dpi);
    // Watch or poll the job
    const tag = await watchJob(apiServiceUrl, ticket, options.usePolling);
    // Assemble the URL to the completed report
    const downloadUrl = `${apiServiceUrl}/job/result?ticket=${ticket}&tag=${tag}`;
    return downloadUrl;
}
exports.run = run;
// Gets the portal item info JSON
async function getPortalItemInfo(itemId, portalUrl, token) {
    const url = `${portalUrl}/sharing/content/items/${itemId}?f=json&token=${token || ""}`;
    const response = await fetch(url);
    // Check if an error response was received during the fetch
    if (!response.ok) {
        throw createError(response.statusText, response.status);
    }
    const portalInfo = (await response.json());
    // Esri wraps errors in a 200 response, so an additional error check is required.
    if (portalInfo.error) {
        throw createError(portalInfo.error.message, portalInfo.error.code);
    }
    return portalInfo;
}
// Ensures that a portal item's info contain the "Geocortex Printing" or "Geocortex Reporting" keyword
function isValidItemType(info) {
    return !(!info.typeKeywords ||
        !Array.from(info.typeKeywords).some((x) => x === "Geocortex Printing" || x === "Geocortex Reporting"));
}
// Gets a bearer token from the service.
async function getBearerToken(serviceUrl, portalUrl, token) {
    var _a;
    if (!token) {
        return "";
    }
    const body = {
        accessToken: token,
        portalUrl,
    };
    const options = {
        method: "POST",
        responseType: "json",
        body: JSON.stringify(body),
        headers: { "Content-Type": "application/json" },
    };
    let response;
    try {
        response = await fetch(`${serviceUrl}/auth/token/run`, options);
    }
    catch {
        throw new Error("A network error occurred fetching an authorization token.");
    }
    if (!response.ok) {
        throw createError(response.statusText, response.status);
    }
    const responseJson = (await response.json());
    const bearerToken = ((_a = responseJson === null || responseJson === void 0 ? void 0 : responseJson.response) === null || _a === void 0 ? void 0 : _a.token) || "";
    return `Bearer ${bearerToken}`;
}
async function startJob(portalUrl, itemId, apiServiceUrl, bearerToken, parameters, culture, dpi) {
    const params = [];
    if (parameters) {
        for (const name in parameters) {
            const value = parameters[name];
            if (Array.isArray(value)) {
                params.push({
                    containsMultipleValues: true,
                    name,
                    values: value,
                });
            }
            else {
                params.push({
                    name,
                    value,
                });
            }
        }
    }
    const body = {
        template: {
            itemId: itemId,
            portalUrl,
        },
        parameters: params,
        culture,
        dpi,
    };
    const requestOptions = {
        method: "POST",
        responseType: "json",
        body: JSON.stringify(body),
        headers: {
            "Content-Type": "application/json",
            Authorization: bearerToken,
        },
    };
    let response;
    try {
        response = await fetch(`${apiServiceUrl}/job/run`, requestOptions);
    }
    catch {
        throw new Error("A network error occurred attempting to run a job.");
    }
    if (!response.ok) {
        throw createError(response.statusText, response.status);
    }
    const responseJson = (await response.json());
    const data = responseJson.response;
    if (!data || !data.ticket) {
        throw createError("The service did not provide a ticket.");
    }
    return data.ticket;
}
async function watchJob(apiServiceUrl, ticket, usePolling = false) {
    let tag;
    if (!usePolling && "WebSocket" in globalThis) {
        tag = await watchJobWithSocket(apiServiceUrl, ticket);
    }
    if (!tag) {
        tag = await pollJob(apiServiceUrl, ticket);
    }
    if (!tag) {
        throw createError("The service did not provide a tag.");
    }
    return tag;
}
async function watchJobWithSocket(apiServiceUrl, ticket) {
    apiServiceUrl = apiServiceUrl.replace(/^http/, "ws");
    return new Promise((resolve) => {
        const socket = new WebSocket(`${apiServiceUrl}/job/artifacts?ticket=${ticket}`);
        socket.addEventListener("message", (message) => {
            const messageJson = (typeof message.data === "string"
                ? JSON.parse(message.data)
                : message.data);
            // The server will send a message with 'final=true' to indicate it is
            // closing the connection. Let's close the socket on our end and resolve
            // the promise.
            if (messageJson.final) {
                socket.close();
                resolve();
                return;
            }
            const tag = checkJobStatusResponse(messageJson);
            if (tag) {
                socket.close();
                resolve(tag);
                return;
            }
            // If no tag is received, resolve and allow fall back to polling.
            resolve();
        });
        socket.addEventListener("error", () => {
            // No need to handle the error, we will fall back to polling.
            resolve();
        });
    });
}
async function pollJob(apiServiceUrl, ticket) {
    const options = {
        method: "GET",
        responseType: "json",
        headers: { "Content-Type": "application/json" },
    };
    let tag;
    while (!tag) {
        await delay(1000);
        let response;
        try {
            response = await fetch(`${apiServiceUrl}/job/artifacts?ticket=${ticket}`, options);
        }
        catch {
            throw new Error("A network error occurred checking the job status.");
        }
        if (!response.ok) {
            throw createError(response.statusText, response.status);
        }
        const responseJson = (await response.json());
        tag = checkJobStatusResponse(responseJson);
    }
    return tag;
}
function checkJobStatusResponse(response) {
    const results = response.results;
    const error = response.error;
    const genericErrorMessage = "The request could not be completed.";
    if (error) {
        throw createError(error.message, error.status);
    }
    else if (results) {
        const result = results.find((result) => result["$type"] === "JobResult");
        if (result) {
            return result.tag;
        }
        const quit = results.find((result) => result["$type"] === "JobQuit");
        if (quit) {
            const error = results.find((result) => result["$type"] && result["$type"].endsWith("error"));
            const message = (error === null || error === void 0 ? void 0 : error.message) || genericErrorMessage;
            throw createError(message, error === null || error === void 0 ? void 0 : error.code);
        }
    }
    else {
        throw createError(genericErrorMessage);
    }
    return undefined;
}
function createError(statusText, status) {
    const message = typeof status === "number"
        ? `Error code: ${status}. Response error: "${statusText}"`
        : `Response error: "${statusText}"`;
    throw new Error(message);
}
function delay(ms = 0) {
    return new Promise((resolve) => {
        setTimeout(resolve, ms);
    });
}
